{-# GHC_OPTIONS -w #-}
{-# Language TemplateHaskell, QuasiQuotes #-}
-- File generated by the BNF Converter (bnfc 2.9.5).

-- | Program to test parser.

module Main where

import Prelude hiding (elem, last, repeat)
import Control.Monad.Logic
import Data.List (nub, sort)

import QQ (hp)

main :: IO ()
main = undefined


{- Relacyjna klasyka -}
-- [hp|
--   % parent(P, C)
--   .decl parent(|String, String).
--   parent("Jozek", "Basia").
--
--   .decl grandparent(|String, String).
--   grandparent(G, C) :- 
--     parent(G, P),
--     parent(P, C).
--
--   .decl gpQuery(String|String).
--   gpQuery(G, C) :- grandparent(G, C).
-- |]
{- gpQuery (MkSolo "Stasiu") -}

data Tree a = Leaf a | Node (Tree a) a (Tree a) deriving (Eq)

sumid :: Num a => [a] -> ([a], a)
sumid xs = (xs, sum xs)

{- Prosty graf -}
[hp|
  .decl node(|Int).
  node(1).
  node(2).
  node(3).
  node(4).
  node(5).
  node(6).
  node(7).

  .decl edge(|Int, Int).
  edge(1, 2).
  edge(2, 3).
  edge(3, 4).
  edge(1, 3).
  edge(1, 4).
  edge(5, 6).
  edge(6, 7).
  edge(5, 7).

  .decl uedge(|Int, Int).
  uedge(X, Y) :- edge(X, Y).
  uedge(X, Y) :- edge(Y, X).

  .decl trails(Int | [Int]).
  trails(X, T) :-
    trailsAux(X, [], T).

  .decl el([a], a|).
  el((X:_), X).
  el((_:L), X) :- el(L, X).

  .decl notEl([a], a|).
  notEl([], _).
  notEl((H:T), X) :-
    H != X,
    notEl(T, X).

  .decl trailsAux(Int, [Int] | [Int]).
  trailsAux(X, V, VR) :-
    once () : el(V, X),
    ext (VR) : reverse(V).
  trailsAux(X, V, T) :-
    once () : notEl(V, X),
    uedge(X, Y),
    trailsAux(Y, (X:V), T).

  .decl notNull([a]|).
  notNull((_:_)).

  .decl label(|Int, Int).
  label(X, L) :-
    node(X),
    collect (Ts) : trails(X, Ts),
    notNull(Ts),
    ext (T) : maximum(Ts),
    notNull(T),
    ext (L) : maximum(T).

  .decl wcc(|Int, [Int]).
  wcc(L, Xs) :-
    node(L),
    collect (Xs) : label(Xs, L),
    notNull(Xs).
|]
{-  -}




{- Podstawowe listy -}
-- [hp|
-- .decl last(a, [a]|).
-- last(X, [X]).
-- last(X, (_:L)) :- last(X, L).
--
-- .decl elem(a, [a]|).
-- elem(X, (X:_)).
-- elem(X, (_:L)) :- elem(X, L).
-- |]

{- Podstawowa arytmetyka -}
-- [hp|
--   .decl add(Int,Int|Int).
--   add(A, B, C) :- C is A + B.
--
--   .decl qa(Int,Int,Int|).
--   qa(A,B,C) :- add(A, B, C).
-- |]

{- Podstawowe relacje -}
-- [hp|
--   .decl geq(Int,Int|).
--   geq(A, B) :- A >= B.
-- |]

{- Listy -}
-- [hp|
--   .decl hd([a]|a).
--   hd((X:_), X).
--
--   .decl ln([a]|Int).
--   ln([], 0).
--   ln((_:T), Len) :- 
--     ln(T, Len0),
--     Len is Len0 + 1.
--
--
--   .decl repeat(Int, a | [a]).
--   repeat(0, _, []).
--   repeat(N, X, (X:L)) :-
--     N > 0,
--     N1 is N - 1,
--     repeat(N1, X, L).
-- |]


-- [hp|
-- .decl maxim[Ord(a)]([a] | a).
-- maxim((H:T), M) :-
--   maximAux(T, H, M).
--
-- .decl maximAux[Ord(a)]([a], a | a).
-- maximAux([], M, M).
-- maximAux((H:T), CM, M) :-
--   H < CM,
--   maximAux(T, CM, M).
-- maximAux((H:T), CM, M) :-
--   H >= CM,
--   maximAux(T, H, M).
--
-- .decl x[Ord(a), Eq(a)](a | a).
-- x(A, A).
-- |]

[hp|
  .decl cumsum[Num(a)]([a] | [a]).
  cumsum([], []).
  cumsum((H:T), S) :- 
    cumsumAux(T, H, S).

  .decl cumsumAux[Num(a)]([a], a | [a]).
  cumsumAux([], S, [S]).
  cumsumAux((H:T), S, (S:ST)) :-
    S1 is S + H,
    cumsumAux(T, S1, ST).
|]
