-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Abs
import Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='     { PT _ (TS _ 1)     }
  '%'      { PT _ (TS _ 2)     }
  '('      { PT _ (TS _ 3)     }
  ')'      { PT _ (TS _ 4)     }
  '*'      { PT _ (TS _ 5)     }
  '+'      { PT _ (TS _ 6)     }
  ','      { PT _ (TS _ 7)     }
  '-'      { PT _ (TS _ 8)     }
  '.'      { PT _ (TS _ 9)     }
  '.decl'  { PT _ (TS _ 10)    }
  '/'      { PT _ (TS _ 11)    }
  ':'      { PT _ (TS _ 12)    }
  ':-'     { PT _ (TS _ 13)    }
  '<'      { PT _ (TS _ 14)    }
  '<='     { PT _ (TS _ 15)    }
  '='      { PT _ (TS _ 16)    }
  '=='     { PT _ (TS _ 17)    }
  '>'      { PT _ (TS _ 18)    }
  '>='     { PT _ (TS _ 19)    }
  'False'  { PT _ (TS _ 20)    }
  'True'   { PT _ (TS _ 21)    }
  '['      { PT _ (TS _ 22)    }
  ']'      { PT _ (TS _ 23)    }
  '_'      { PT _ (TS _ 24)    }
  'is'     { PT _ (TS _ 25)    }
  '|'      { PT _ (TS _ 26)    }
  L_integ  { PT _ (TI _)       }
  L_quoted { PT _ (TL _)       }
  L_UIdent { PT _ (T_UIdent _) }
  L_LIdent { PT _ (T_LIdent _) }

%%

Integer :: { (Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

UIdent :: { (Abs.BNFC'Position, Abs.UIdent) }
UIdent  : L_UIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.UIdent (tokenText $1)) }

LIdent :: { (Abs.BNFC'Position, Abs.LIdent) }
LIdent  : L_LIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LIdent (tokenText $1)) }

Program :: { (Abs.BNFC'Position, Abs.Program) }
Program : ListDef { (fst $1, Abs.Program (fst $1) (snd $1)) }

ListDef :: { (Abs.BNFC'Position, [Abs.Def]) }
ListDef
  : Def '.' { (fst $1, (:[]) (snd $1)) }
  | Def '.' ListDef { (fst $1, (:) (snd $1) (snd $3)) }

Def :: { (Abs.BNFC'Position, Abs.Def) }
Def
  : '.decl' LIdent '(' ListTypeArg '|' ListTypeArg ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TDef (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | DeclHeader { (fst $1, Abs.DFact (fst $1) (snd $1)) }
  | DeclHeader ':-' ListStmt { (fst $1, Abs.DRule (fst $1) (snd $1) (snd $3)) }

TypeArg :: { (Abs.BNFC'Position, Abs.TypeArg) }
TypeArg
  : UIdent { (fst $1, Abs.TALit (fst $1) (snd $1)) }
  | LIdent { (fst $1, Abs.TAGen (fst $1) (snd $1)) }
  | '[' TypeArg ']' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TAList (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | TypeArg '(' ListTypeArg ')' { (fst $1, Abs.TAApp (fst $1) (snd $1) (snd $3)) }

ListTypeArg :: { (Abs.BNFC'Position, [Abs.TypeArg]) }
ListTypeArg
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | TypeArg { (fst $1, (:[]) (snd $1)) }
  | TypeArg ',' ListTypeArg { (fst $1, (:) (snd $1) (snd $3)) }

DeclHeader :: { (Abs.BNFC'Position, Abs.DeclHeader) }
DeclHeader
  : LIdent '(' ListTerm ')' { (fst $1, Abs.DHeader (fst $1) (snd $1) (snd $3)) }

Stmt :: { (Abs.BNFC'Position, Abs.Stmt) }
Stmt
  : 'True' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.STrue (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | 'False' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.SFalse (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | LIdent '(' ListTerm ')' { (fst $1, Abs.SCall (fst $1) (snd $1) (snd $3)) }
  | UIdent '=' Term { (fst $1, Abs.SAss (fst $1) (snd $1) (snd $3)) }
  | UIdent 'is' IExp { (fst $1, Abs.SIs (fst $1) (snd $1) (snd $3)) }
  | IExp RelOp IExp { (fst $1, Abs.SRel (fst $1) (snd $1) (snd $2) (snd $3)) }

IExp3 :: { (Abs.BNFC'Position, Abs.IExp) }
IExp3
  : UIdent { (fst $1, Abs.IEVar (fst $1) (snd $1)) }
  | Integer { (fst $1, Abs.IELit (fst $1) (snd $1)) }
  | '(' IExp ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

IExp2 :: { (Abs.BNFC'Position, Abs.IExp) }
IExp2
  : '-' IExp3 { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.IENeg (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | IExp3 { (fst $1, (snd $1)) }

IExp1 :: { (Abs.BNFC'Position, Abs.IExp) }
IExp1
  : IExp1 MulOp IExp2 { (fst $1, Abs.IEMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | IExp2 { (fst $1, (snd $1)) }

IExp :: { (Abs.BNFC'Position, Abs.IExp) }
IExp
  : IExp AddOp IExp1 { (fst $1, Abs.IEAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | IExp1 { (fst $1, (snd $1)) }

AddOp :: { (Abs.BNFC'Position, Abs.AddOp) }
AddOp
  : '+' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Plus (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Minus (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (Abs.BNFC'Position, Abs.MulOp) }
MulOp
  : '*' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Times (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Div (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Mod (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

RelOp :: { (Abs.BNFC'Position, Abs.RelOp) }
RelOp
  : '<' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LTH (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.GTH (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.GE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '==' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.EQU (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.NE (uncurry Abs.BNFC'Position (tokenLineCol $1))) }

Term :: { (Abs.BNFC'Position, Abs.Term) }
Term
  : String { (fst $1, Abs.TStr (fst $1) (snd $1)) }
  | Integer { (fst $1, Abs.TInt (fst $1) (snd $1)) }
  | UIdent { (fst $1, Abs.TVar (fst $1) (snd $1)) }
  | '_' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TIgnore (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '[' ListTerm ']' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TList (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Term ':' Term ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TCons (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListTerm :: { (Abs.BNFC'Position, [Abs.Term]) }
ListTerm
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | Term { (fst $1, (:[]) (snd $1)) }
  | Term ',' ListTerm { (fst $1, (:) (snd $1) (snd $3)) }

ListStmt :: { (Abs.BNFC'Position, [Abs.Stmt]) }
ListStmt
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | Stmt { (fst $1, (:[]) (snd $1)) }
  | Stmt ',' ListStmt { (fst $1, (:) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Abs.Program
pProgram = fmap snd . pProgram_internal
}

