-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Abs
import Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('          { PT _ (TS _ 1)         }
  ')'          { PT _ (TS _ 2)         }
  ','          { PT _ (TS _ 3)         }
  '.'          { PT _ (TS _ 4)         }
  '.decl'      { PT _ (TS _ 5)         }
  ':'          { PT _ (TS _ 6)         }
  ':-'         { PT _ (TS _ 7)         }
  '='          { PT _ (TS _ 8)         }
  'False'      { PT _ (TS _ 9)         }
  'True'       { PT _ (TS _ 10)        }
  '['          { PT _ (TS _ 11)        }
  ']'          { PT _ (TS _ 12)        }
  '_'          { PT _ (TS _ 13)        }
  '|'          { PT _ (TS _ 14)        }
  L_integ      { PT _ (TI _)           }
  L_quoted     { PT _ (TL _)           }
  L_UIdent     { PT _ (T_UIdent _)     }
  L_LIdent     { PT _ (T_LIdent _)     }
  L_Identifier { PT _ (T_Identifier _) }

%%

Integer :: { (Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

UIdent :: { (Abs.BNFC'Position, Abs.UIdent) }
UIdent  : L_UIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.UIdent (tokenText $1)) }

LIdent :: { (Abs.BNFC'Position, Abs.LIdent) }
LIdent  : L_LIdent { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.LIdent (tokenText $1)) }

Identifier :: { (Abs.BNFC'Position, Abs.Identifier) }
Identifier  : L_Identifier { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.Identifier (tokenText $1)) }

Program :: { (Abs.BNFC'Position, Abs.Program) }
Program : ListDef { (fst $1, Abs.Program (fst $1) (snd $1)) }

ListDef :: { (Abs.BNFC'Position, [Abs.Def]) }
ListDef
  : Def '.' { (fst $1, (:[]) (snd $1)) }
  | Def '.' ListDef { (fst $1, (:) (snd $1) (snd $3)) }

Def :: { (Abs.BNFC'Position, Abs.Def) }
Def
  : '.decl' LIdent '(' ListTypeArg '|' ListTypeArg ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TDef (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | DeclHeader { (fst $1, Abs.DFact (fst $1) (snd $1)) }
  | DeclHeader ':-' ListStmt { (fst $1, Abs.DRule (fst $1) (snd $1) (snd $3)) }

TypeArg :: { (Abs.BNFC'Position, Abs.TypeArg) }
TypeArg
  : Identifier { (fst $1, Abs.TALit (fst $1) (snd $1)) }
  | '[' TypeArg ']' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TAList (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListTypeArg :: { (Abs.BNFC'Position, [Abs.TypeArg]) }
ListTypeArg
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | TypeArg { (fst $1, (:[]) (snd $1)) }
  | TypeArg ',' ListTypeArg { (fst $1, (:) (snd $1) (snd $3)) }

DeclHeader :: { (Abs.BNFC'Position, Abs.DeclHeader) }
DeclHeader
  : LIdent '(' ListTerm ')' { (fst $1, Abs.DHeader (fst $1) (snd $1) (snd $3)) }

Stmt :: { (Abs.BNFC'Position, Abs.Stmt) }
Stmt
  : 'True' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.STrue (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | 'False' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.SFalse (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | LIdent '(' ListTerm ')' { (fst $1, Abs.SCall (fst $1) (snd $1) (snd $3)) }
  | UIdent '=' Term { (fst $1, Abs.SAss (fst $1) (snd $1) (snd $3)) }

Term :: { (Abs.BNFC'Position, Abs.Term) }
Term
  : String { (fst $1, Abs.TStr (fst $1) (snd $1)) }
  | Integer { (fst $1, Abs.TInt (fst $1) (snd $1)) }
  | UIdent { (fst $1, Abs.TVar (fst $1) (snd $1)) }
  | '_' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TIgnore (uncurry Abs.BNFC'Position (tokenLineCol $1))) }
  | '[' ListTerm ']' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TList (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Term ':' Term ')' { (uncurry Abs.BNFC'Position (tokenLineCol $1), Abs.TCons (uncurry Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListTerm :: { (Abs.BNFC'Position, [Abs.Term]) }
ListTerm
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | Term { (fst $1, (:[]) (snd $1)) }
  | Term ',' ListTerm { (fst $1, (:) (snd $1) (snd $3)) }

ListStmt :: { (Abs.BNFC'Position, [Abs.Stmt]) }
ListStmt
  : {- empty -} { (Abs.BNFC'NoPosition, []) }
  | Stmt { (fst $1, (:[]) (snd $1)) }
  | Stmt ',' ListStmt { (fst $1, (:) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Abs.Program
pProgram = fmap snd . pProgram_internal
}

