<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <meta name="date" content="2022-06-06" />
  <title>Advanced Functional Programming</title>
  <style type="text/css">
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Advanced Functional Programming</h1>
  <p class="subtitle">The Pleasure and Pain of Dependent Types in Haskell</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">June 6, 2022</p>
</div>
<div class="slide section level1">

<meta name="duration" content="80" />
</div>
<div id="plan" class="slide section level1">
<h1>Plan</h1>
<p><a href="http://homepages.inf.ed.ac.uk/slindley/papers/hasochism.pdf">Hasochism - The Pleasure and Pain of Dependently Typed Haskell Programming</a></p>
<ol style="list-style-type: decimal">
<li><p>Kinds</p></li>
<li><p>GADT - <a href="https://en.wikibooks.org/wiki/Haskell/GADT">https://en.wikibooks.org/wiki/Haskell/GADT</a></p></li>
<li><p>Type promotion - <a href="https://github.com/slindley/dependent-haskell">https://github.com/slindley/dependent-haskell</a> <!--
``` {.haskell}
    data Nat = Z | S Nat
    data Vec :: Nat -> * -> * where
    vhead :: Vec (S n) a -> a
```
--></p></li>
<li><p>Type Families</p></li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m::</span><span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   vappend ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">?</span><span class="ot"> ::</span> <span class="dt">Vec</span>(m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Dynamic dependencies, singletons</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">data</span> <span class="dt">Natty</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   vchop ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">?</span><span class="ot"> ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span></code></pre></div>
</div>
<div id="plan-b" class="slide section level1">
<h1>Plan B</h1>
<ol start="6" style="list-style-type: decimal">
<li>Static dependencies, Proxy</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   vtake1 ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">NP</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span></code></pre></div>
<ol start="7" style="list-style-type: decimal">
<li>Kind polymorphism</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">data</span> <span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> i</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   vtake2 ::</span> <span class="dt">Natty</span> m <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span></code></pre></div>
<ol start="8" style="list-style-type: decimal">
<li>TypeApplication, getting rid of Proxy</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake4 two v</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake4 ::</span> <span class="kw">forall</span> n m a<span class="op">.</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span></code></pre></div>
<ol start="9" style="list-style-type: decimal">
<li>Type equality and proofs</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">:~:</span> b <span class="ot">=</span> (a <span class="op">~</span> b) <span class="ot">=&gt;</span> <span class="dt">Refl</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_id_r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> (n <span class="op">:+</span> <span class="dt">Z</span>) <span class="op">:~:</span> n</span></code></pre></div>
</div>
<div id="kinds" class="slide section level1">
<h1>Kinds</h1>
<ul>
<li><p>Operations on values are described by types</p></li>
<li><p>Operations on types are described by kinds</p></li>
<li><p>Types (e.g. <code>Int</code>) are of kind <code>*</code></p></li>
<li><p>One argument constructors (e.g. <code>Maybe</code>) are of kind <code>* -&gt; *</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="op">*</span>)<span class="op">.</span>a <span class="ot">-&gt;</span> f a</span></code></pre></div></li>
<li><p>There exist also more complex kinds, e.g. for monad transformers:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>)) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    lift ::</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">=&gt;</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="op">*</span>)<span class="op">.</span>m a <span class="ot">-&gt;</span> t m a</span></code></pre></div></li>
</ul>
<p>GHC has also an internal kind <code>#</code> for unboxed types (e.g. <code>Int#</code>)</p>
<p>As we shall see, more kinds may be introduced.</p>
</div>
<div id="huttons-razor-expr1" class="slide section level1">
<h1>Hutton’s Razor: Expr1</h1>
<p>Consider a simple expression evaluator:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">I</span> n)       <span class="ot">=</span> n</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> eval e1 <span class="op">+</span> eval e2</span></code></pre></div>
<p>What if we try to add <code>Bool</code>?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Eq</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>What type should <code>eval</code> have?</p>
</div>
<div id="expr2" class="slide section level1">
<h1>Expr2</h1>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Eq</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- eval :: Either Int Bool ?</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- eval (Add (B True) (I 1)) = ?</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Bool</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">I</span> n)       <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> n)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">B</span> n)       <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> n)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>eval _ <span class="ot">=</span> <span class="fu">undefined</span>       <span class="co">-- Exercise</span></span></code></pre></div>
<p>How can we make typechecker reject <code>eval (Add (B True) (I 1))</code> ?</p>
</div>
<div id="phantom-types" class="slide section level1">
<h1>Phantom types</h1>
<p>A phantom type is a parametrised type whose parameters do not all appear on the right-hand side of its definition</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">USD</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">EUR</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Amount</span> a <span class="ot">=</span> <span class="dt">Amount</span> <span class="dt">Double</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Num</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ot">usd ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Amount</span> <span class="dt">USD</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>usd <span class="ot">=</span> <span class="dt">Amount</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="ot">eur ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Amount</span> <span class="dt">EUR</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>eur <span class="ot">=</span> <span class="dt">Amount</span></span></code></pre></div>
<pre><code>&gt; usd 5 + usd 5
Amount 10.0
&gt; usd 5 + eur 5

&lt;interactive&gt;:4:9: error:
    • Couldn&#39;t match type ‘EUR’ with ‘USD’
      Expected type: Amount USD
        Actual type: Amount EUR
    • In the second argument of ‘(+)’, namely ‘eur 5’
      In the expression: usd 5 + eur 5
      In an equation for ‘it’: it = usd 5 + eur 5</code></pre>
</div>
<div id="expr3---phantom-types" class="slide section level1">
<h1>Expr3 - Phantom types</h1>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="ot">=</span> <span class="dt">I</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">B</span> <span class="dt">Bool</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Add</span> (<span class="dt">Expr</span> <span class="dt">Int</span>) (<span class="dt">Expr</span> <span class="dt">Int</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Eq</span>  (<span class="dt">Expr</span> <span class="dt">Int</span>) (<span class="dt">Expr</span> <span class="dt">Int</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">I</span> n) <span class="ot">=</span> n <span class="co">-- Error: Couldn&#39;t match expected type ‘a’ with actual type ‘Int’</span></span></code></pre></div>
<p>besides <code>Add (B True) (I 1)</code> still typechecks.</p>
<p>The problem is that we have</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span></code></pre></div>
<p>but want rather</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span></code></pre></div>
</div>
<div id="gadts---generalised-abstract-data-types" class="slide section level1">
<h1>GADTs - Generalised Abstract Data Types</h1>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">I</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Add</span><span class="ot"> ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eq</span><span class="ot">  ::</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Bool</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- exercise: allow comparing booleans, e.g `Eq (B True) (B True)`</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">I</span> n)       <span class="ot">=</span> n</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">B</span> b)       <span class="ot">=</span> b</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> eval e1 <span class="op">+</span> eval e2</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Eq</span>  e1 e2) <span class="ot">=</span> eval e1 <span class="op">==</span> eval e2</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Expr</span> a)</span></code></pre></div>
</div>
<div id="vec" class="slide section level1">
<h1>Vec</h1>
<p>Recall an example from the first lecture</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Zero</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Succ</span> n</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VNil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a <span class="ot">-&gt;</span> a</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>vhead (x <span class="op">:&gt;</span> xs) <span class="ot">=</span> x</span></code></pre></div>
<p>Let us see how far we can go with dependent vectors in Haskell</p>
</div>
<div id="promotion" class="slide section level1">
<h1>Promotion</h1>
<p>If we have the <code>Nat</code> datatype, types for zero and successor can be automatically generated:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs, DataKinds, KindSignatures #-}</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span><span class="ot"> ::</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This defines</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Type Nat</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Value constructors: Z, S</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Promotion (lifting) to type level yields</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- kind Nat</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- type constructors: &#39;Z :: Nat; &#39;S :: Nat -&gt; Nat</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- &#39;s can be omitted in most cases, but...</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- data P          -- 1</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Prom = P   -- 2</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- type T = P      -- 1 or promoted 2?</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- quote disambiguates:</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- type T1 = P     -- 1</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- type T2 = &#39;P    -- promoted 2</span></span></code></pre></div>
</div>
<div id="vec-with-promoted-nat" class="slide section level1">
<h1>Vec with promoted Nat</h1>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span><span class="ot"> ::</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nat is a kind, and so is Nat -&gt; * -&gt; *</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">6</span> <span class="op">:&gt;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">V0</span><span class="ot">   ::</span> <span class="dt">Vec</span> <span class="dt">&#39;Z</span> a</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&gt;) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">&#39;S</span> n) a</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> n a)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="ot">vhead ::</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a <span class="ot">-&gt;</span> a</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>vhead (x<span class="op">:&gt;</span>_) <span class="ot">=</span> x</span></code></pre></div>
<p><strong>Exercise:</strong> define <code>vtail</code> (the type requires more thought than the body)</p>
</div>
<div id="other-promotion-examples" class="slide section level1">
<h1>Other promotion examples</h1>
<p>Heterogenous lists:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="co">-- [*] is a list of types</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HNil</span><span class="ot">  ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HCons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HList</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> (a &#39;<span class="op">:</span> t)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">foo0 ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>foo0 <span class="ot">=</span> <span class="dt">HNil</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="ot">foo1 ::</span> <span class="dt">HList</span> &#39;[<span class="dt">Int</span>]</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>foo1 <span class="ot">=</span> <span class="dt">HCons</span> <span class="dv">3</span> <span class="dt">HNil</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="ot">foo2 ::</span> <span class="dt">HList</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>]</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>foo2 <span class="ot">=</span> <span class="fu">undefined</span>  <span class="co">-- (easy) exercise</span></span></code></pre></div>
<p>It is in a sense a generalisation of vectors: <code>Nat ~ [()]</code></p>
</div>
<div id="vector-concatenation" class="slide section level1">
<h1>Vector concatenation</h1>
<p>We have seen that addition can be defined with classes:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Add</span> (<span class="ot">a::</span><span class="dt">Nat</span>) (<span class="ot">b::</span><span class="dt">Nat</span>) (<span class="ot">c::</span><span class="dt">Nat</span>)  <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Add</span> <span class="dt">Z</span> b b</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">S</span> a) b (<span class="dt">S</span> c)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="ot">vappend ::</span> (<span class="dt">Add</span> m n r) <span class="ot">=&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> s a</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>vappend <span class="dt">V0</span> ys <span class="ot">=</span> ys</span></code></pre></div>
<p>alas…</p>
<pre><code>error: …
    • Could not deduce: n ~ r
      from the context: m ~ &#39;Z</code></pre>
<p>The constraint checker cannot infer <code>n = r</code> from <code>m = 0</code></p>
</div>
<div id="type-families" class="slide section level1">
<h1>Type families</h1>
<p>Type families provide more data for the constraint checker</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Z</span> <span class="op">:+</span> m <span class="ot">=</span> m</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">S</span> n) <span class="op">:+</span> m <span class="ot">=</span> <span class="dt">S</span> (n <span class="op">:+</span> m)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ot">vapp ::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>vapp <span class="dt">V0</span> ys <span class="ot">=</span> ys</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>vapp (x<span class="op">:&gt;</span>xs) ys <span class="ot">=</span> x<span class="op">:&gt;</span>(vapp xs ys)</span></code></pre></div>
<p>Now <code>Z :+ m</code> can be reduced to <code>m</code> (at compile time)</p>
<p><strong>Exercise:</strong> define multiplication</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="op">:*</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span></code></pre></div>
</div>
<div id="indexing" class="slide section level1">
<h1>Indexing</h1>
<p>You have probably seen some variant of <code>Fin</code> in Coq/Idris</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- atIndex :: Vec n a -&gt; (m &lt; n) -&gt; a</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Fin n - numbers smaller than n</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fin</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FinZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)          <span class="co">-- zero is less than any successor</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FinS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n) <span class="co">-- n is less than (n+1)</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="ot">atIndex ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> a</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>atIndex (x<span class="op">:&gt;</span>_) <span class="dt">FinZ</span> <span class="ot">=</span> x</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>atIndex (_<span class="op">:&gt;</span>xs) (<span class="dt">FinS</span> k) <span class="ot">=</span> atIndex xs k</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Exercise - why not:</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- atIndex :: Vec (S n) a -&gt; ... ?</span></span></code></pre></div>
</div>
<div id="replicate" class="slide section level1">
<h1>Replicate</h1>
<p>Let’s try to define a vector counterpart of <code>replicate :: Int -&gt; a -&gt; [a]</code></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vreplicate ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>vreplicate <span class="dt">Z</span> _ <span class="ot">=</span> <span class="dt">V0</span>   <span class="co">--  Expected type: Vec n a</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                      <span class="co">--  Actual type:   Vec &#39;Z a</span></span></code></pre></div>
<p>more precisely, we would like</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vreplicate2 ::</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span></code></pre></div>
<p>…but <code>n::Nat</code> has no inhabitants</p>
<p><em>Exercise:</em> try your own ideas for <code>vreplicate</code></p>
<p>Before we implement <code>vreplicate</code> let us look at some other functions.</p>
</div>
<div id="vchop" class="slide section level1">
<h1>vchop</h1>
<p>We want to write a function dual to <code>vappend</code>, chopping a vector in two</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">--|</span> chop a vector <span class="kw">in</span> two</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">vchop1 ::</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>vchop1 _ _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Can we at least write a test for it?</p>
<pre><code>-- &gt;&gt;&gt; vchop1 (1 :&gt; 2 :&gt; V0)
-- ???</code></pre>
</div>
<div id="vchop2" class="slide section level1">
<h1>vchop2</h1>
<p>We need to count to <code>m</code>. Here’s an ugly solution:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Chop a vector in two, using first argument as a measure</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vchop2 (undefined :&gt; V0) (1 :&gt; 2 :&gt; V0)</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- (1 :&gt; V0,2 :&gt; V0)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- NB if we had `vreplicate`, we might write</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- vchop2 (vreplicate (S Z) undefined) (1 :&gt; 2 :&gt; V0)</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="ot">vchop2 ::</span> <span class="dt">Vec</span> m x <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>vchop2 <span class="dt">V0</span> xs <span class="ot">=</span> (<span class="dt">V0</span>, xs)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>vchop2 (_<span class="op">:&gt;</span>m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> (x<span class="op">:&gt;</span>ys, zs) <span class="kw">where</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  (ys, zs) <span class="ot">=</span> vchop2 m xs</span></code></pre></div>
</div>
<div id="singleton" class="slide section level1">
<h1>Singleton</h1>
<p>Using a vector is an overkill, we need just its length.</p>
<p>But <code>Nat</code> is not precise enough; it’s like <code>[a]</code> - no size checking.</p>
<p>Idea: create a representant of every element of kind Nat</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- SNat n ~~ Vec n ()</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SNat</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span>(<span class="dt">SNat</span> n)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> (<span class="dt">SNat</span> m) <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span>(m <span class="op">:+</span> n)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>add <span class="dt">SZ</span> n <span class="ot">=</span> n</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">SS</span> m) n <span class="ot">=</span> <span class="dt">SS</span> (add m n)</span></code></pre></div>
<p><strong>Exercise:</strong> define multiplication</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mul ::</span> (<span class="dt">SNat</span> m) <span class="ot">-&gt;</span> (<span class="dt">SNat</span> n) <span class="ot">-&gt;</span> <span class="dt">SNat</span>(m <span class="op">:*</span> n)</span></code></pre></div>
</div>
<div id="vchop3" class="slide section level1">
<h1>vchop3</h1>
<p>With <code>SNat</code> we can implement <code>vchop</code> properly:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | chop a vector in two parts</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vchop (SS SZ) (Vcons 1 (Vcons 2 V0))</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- (Vcons 1 V0,Vcons 2 V0)</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>vchop <span class="ot">=</span> vchop3</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="ot">vchop3 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span>(m<span class="op">:+</span>n) a <span class="ot">-&gt;</span> (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>vchop3 <span class="dt">SZ</span> xs <span class="ot">=</span> (<span class="dt">V0</span>, xs)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>vchop3 (<span class="dt">SS</span> m) (<span class="dt">Vcons</span> x xs) <span class="ot">=</span> (<span class="dt">Vcons</span> x ys, zs) <span class="kw">where</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  (ys,zs) <span class="ot">=</span> vchop3 m xs</span></code></pre></div>
</div>
<div id="comparisons-and-another-way-of-vector-indexing" class="slide section level1">
<h1>Comparisons and another way of vector indexing</h1>
<p>Singletons also let us get rid of <code>Fin</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- atIndex :: Vec n a -&gt; Fin n -&gt; a</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">nth ::</span> (m<span class="op">:&lt;</span>n) <span class="op">~</span> <span class="dt">&#39;True</span> <span class="ot">=&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> a</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>nth <span class="dt">SZ</span> (a<span class="op">:&gt;</span>_)  <span class="ot">=</span> a</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>nth (<span class="dt">SS</span> m&#39;) (_<span class="op">:&gt;</span>xs) <span class="ot">=</span> nth m&#39; xs</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m::</span><span class="dt">Nat</span>) <span class="op">:&lt;</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> m <span class="op">:&lt;</span> <span class="dt">&#39;Z</span> <span class="ot">=</span> <span class="dt">&#39;False</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">&#39;Z</span> <span class="op">:&lt;</span> (<span class="dt">&#39;S</span> n) <span class="ot">=</span> <span class="dt">&#39;True</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">&#39;S</span> m) <span class="op">:&lt;</span> (<span class="dt">&#39;S</span> n) <span class="ot">=</span> m <span class="op">:&lt;</span> n</span></code></pre></div>
<p>Apart from ordinary class constraints, we may use equality constraints.</p>
<p><code>(m:&lt;n) ~ 'True</code> is an example of such a constraint</p>
<p><code>nth</code> typechecks without this constraint, but so does <code>nth SZ V0</code> which is unsafe.</p>
<p>With the constraint, we get:</p>
<pre><code>&gt; nth SZ V0
    • Couldn&#39;t match type ‘&#39;False’ with ‘&#39;True’
        arising from a use of ‘nth’
    • In the expression: nth SZ V0</code></pre>
</div>
<div id="the-singletons-library" class="slide section level1">
<h1>The singletons library</h1>
<p>We can avoid writing singleton boilerplate using <a href="https://hackage.haskell.org/package/singletons">singletons</a> and TH</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Singletons</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(singletons [d|</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    data Nat :: * where</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>      Z :: Nat</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>      S :: Nat -&gt; Nat</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    plus :: Nat -&gt; Nat -&gt; Nat</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    plus Z     m = m</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    plus (S n) m = S (plus n m)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    |])</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a><span class="ot">vchop ::</span> <span class="dt">Sing</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span>(<span class="dt">Plus</span> m n) a <span class="ot">-&gt;</span>  (<span class="dt">Vec</span> m a, <span class="dt">Vec</span> n a)</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>vchop <span class="dt">SZ</span> xs <span class="ot">=</span> (<span class="dt">V0</span>, xs)</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>vchop (<span class="dt">SS</span> m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> (x<span class="op">:&gt;</span>ys, zs) <span class="kw">where</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>  (ys,zs) <span class="ot">=</span> vchop m xs</span></code></pre></div>
</div>
<div id="vreplicate" class="slide section level1">
<h1>vreplicate</h1>
<p>Also <code>vreplicate</code> becomes easy:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | `vreplicate n a` is a vector of n copies of a</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vreplicate (SS SZ) 1</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; V0</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vreplicate (SS (SS SZ)) 1</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="ot">vreplicate ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>vreplicate <span class="dt">SZ</span> _ <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>vreplicate (<span class="dt">SS</span> n) x <span class="ot">=</span> x <span class="op">:&gt;</span> (vreplicate n x)</span></code></pre></div>
<p><strong>Exercise:</strong> define</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vcycle ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (n <span class="op">:*</span> m) a</span></code></pre></div>
</div>
<div id="vtake" class="slide section level1">
<h1>vtake</h1>
<p>We want to define a vector counterpart of <code>take</code>, similarly to <code>vchop</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- vchop :: SNat m -&gt; Vec(m :+ n) a -&gt; (Vec m a, Vec n a)</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake1  ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>vtake1      <span class="dt">SZ</span>     xs     <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>vtake1     (<span class="dt">SS</span> m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake1 m xs</span></code></pre></div>
<pre class="error"><code>error: …
    • Could not deduce: (n1 :+ n0) ~ n2
      from the context: m ~ &#39;S n1
      Expected type: Vec (n1 :+ n0) a
        Actual type: Vec n2 a
      In the second argument of ‘vtake1’, namely ‘xs’
      In the second argument of ‘(:&gt;)’, namely ‘vtake1 m xs’
    • Relevant bindings include
        xs :: Vec n2 a
        m :: SNat n1</code></pre>
<p>The compiler cannot type the recursive case; we’ll see why in a moment.</p>
<p>NB <code>AllowAmbiguousTypes</code> is needed if we want the compiler to even try to typecheck this.</p>
<p><strong>Exercise:</strong> try defining <code>vtake</code> using <code>vchop</code></p>
</div>
<div id="injectivity" class="slide section level1">
<h1>Injectivity</h1>
<pre><code>    • Could not deduce: (n1 :+ n0) ~ n2
      from the context: m ~ &#39;S n1</code></pre>
<p>The problem is whether <code>(m :+)</code> is injective.</p>
<p><code>Maybe a ~ Maybe b =&gt; a ~ b</code></p>
<p>but it’s harder to see, if</p>
<p><code>m :+ n0 ~ m :+ n1 =&gt; n0 ~ n1</code></p>
<p>More precisely in the type</p>
<p><code>vtake1 :: SNat m -&gt; Vec (m :+ n) -&gt; Vec m x</code></p>
<p>we lack a “handle” on <code>n</code>; with real dependent types we would write</p>
<pre><code>(m : Nat) -&gt; (n : Nat) -&gt; Vec (m + n) x -&gt; Vec m x</code></pre>
</div>
<div id="using-a-dynamic-handle" class="slide section level1">
<h1>Using a dynamic handle</h1>
<p>we lack a “handle” on <code>n</code>; with real dependent types we would write</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>(m <span class="op">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (n <span class="op">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">+</span> n) x <span class="ot">-&gt;</span> <span class="dt">Vec</span> m x</span></code></pre></div>
<p>So let us try translating this using singletons:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake1&#39; ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>vtake1&#39; <span class="dt">SZ</span> _  _ <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>vtake1&#39; (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake1&#39; m n xs</span></code></pre></div>
<p>This works, but we need to pass an additional parameter - the length <code>n</code> of the vector remainder:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="ot">=</span> <span class="dv">1</span> <span class="op">:&gt;</span> (<span class="dv">1</span> <span class="op">:&gt;</span> (<span class="dv">1</span> <span class="op">:&gt;</span> <span class="dt">V0</span>)); two <span class="ot">=</span> <span class="dt">SS</span>(<span class="dt">SS</span> <span class="dt">SZ</span>) <span class="kw">in</span> vtake1&#39; two (<span class="dt">SS</span> <span class="dt">SZ</span>) v</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">:&gt;</span> (<span class="dv">1</span> <span class="op">:&gt;</span> <span class="dt">V0</span>)</span></code></pre></div>
<p>But here we do not need the value of <code>n</code>, only its type.</p>
</div>
<div id="proxy---a-static-handle" class="slide section level1">
<h1><code>Proxy</code> - a static handle</h1>
<p>Let us try to build a static handle:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Nat Proxy</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake2 two NP v</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake2 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">NP</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>vtake2 <span class="dt">SZ</span>     _ _ <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>vtake2 (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake2 m n xs</span></code></pre></div>
<p>Note: this is different from a singleton, which is a runtime value; a proxy is only needed during typechecking.</p>
</div>
<div id="a-universal-handle" class="slide section level1">
<h1>A universal handle</h1>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Nat Proxy</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span> <span class="dt">NP</span><span class="ot"> ::</span> <span class="dt">NP</span> n</span></code></pre></div>
<p>there is no reason why our handle should depend on <code>Nat</code>, so why not make it polymorphic?</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Generic Proxy</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="ot">i::</span>k)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake3 two Proxy v</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake3 ::</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>vtake3 <span class="dt">SZ</span>     _ _ <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>vtake3 (<span class="dt">SS</span> m) n (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake3 m n xs</span></code></pre></div>
<p><strong>Note:</strong> <code>k</code> is a kind variable, hence the need for <code>PolyKinds</code></p>
</div>
<div id="back-to-the-future-or-another-take-on-vtake1" class="slide section level1">
<h1>Back to the future or another take on vtake1</h1>
<p>Since 8.0 GHC allows explicit type applications, e.g.</p>
<pre><code>Prelude&gt; :set -XTypeApplications
Prelude&gt; :t read
read :: Read a =&gt; String -&gt; a
Prelude&gt; read @Int &quot;42&quot;
42
Prelude&gt; read @Double &quot;42&quot;
42.0</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- vtake4 requires:</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- {-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- {-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; let v = 1 :&gt; (1 :&gt; (1 :&gt; V0)); two = SS(SS SZ) in vtake4 two v</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (1 :&gt; V0)</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="ot">vtake4 ::</span> <span class="kw">forall</span> n m a<span class="op">.</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>vtake4 <span class="dt">SZ</span> _ <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>vtake4 (<span class="dt">SS</span> m) (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> x <span class="op">:&gt;</span> vtake4 <span class="op">@</span>n m xs</span></code></pre></div>
</div>
<div id="implicit-pi" class="slide section level1">
<h1>Implicit Pi</h1>
<p>We can use type classes to infer singletons:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SNAT</span>(<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  snat ::</span> <span class="dt">SNat</span> n</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SNAT</span> <span class="dt">Z</span> <span class="kw">where</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  snat <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SNAT</span> n <span class="ot">=&gt;</span> <span class="dt">SNAT</span> (<span class="dt">S</span> n) <span class="kw">where</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  snat <span class="ot">=</span> <span class="dt">SS</span> snat</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vtrunc Proxy (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; V0) :: Vec (S (S Z)) Int</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :&gt; (2 :&gt; V0)</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="ot">vtrunc ::</span> <span class="dt">SNAT</span> m <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m <span class="op">:+</span> n) a <span class="ot">-&gt;</span> <span class="dt">Vec</span> m a</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>vtrunc <span class="ot">=</span> vtake3 snat</span></code></pre></div>
<p><strong>Exercise:</strong> get rid of both proxy and singletons:</p>
<pre><code>-- &gt;&gt;&gt; vtrunc2 (1 :&gt; 2 :&gt; 3 :&gt; 4 :&gt; V0) :: Vec (S (S Z)) Int
-- 1 :&gt; (2 :&gt; V0)
vtrunc2 :: forall n m a. SNAT m =&gt; Vec (m :+ n) a -&gt; Vec m a</code></pre>
</div>
<div id="reversing-vec" class="slide section level1">
<h1>Reversing Vec</h1>
<p>Let’s try a naive vector reverse:</p>
<pre><code>rev1 :: Vec n a -&gt; Vec n a
vrev1 V0 = V0
vrev1 (x:&gt;xs) = vapp (vrev1 xs) (x:&gt;V0)</code></pre>
<p>As you might suspect, this does not work:</p>
<pre><code>    • Could not deduce: (n1 :+ &#39;S &#39;Z) ~ &#39;S n1
      from the context: n ~ &#39;S n1</code></pre>
<p>Oh no, we need to prove <code>n + 1 ~ S n</code></p>
</div>
<div id="vrev2" class="slide section level1">
<h1>vrev2</h1>
<p>We may work around this using a specialized “append one” function:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | vrev2</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; vrev2 (1:&gt;2:&gt;3:&gt;V0)</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 3 :&gt; (2 :&gt; (1 :&gt; V0))</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="ot">vrev2 ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>vrev2 <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>vrev2 (x<span class="op">:&gt;</span>xs) <span class="ot">=</span> snoc (vrev2 xs) x</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="ot">snoc ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>snoc <span class="dt">V0</span> y <span class="ot">=</span> y <span class="op">:&gt;</span> <span class="dt">V0</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>snoc (x<span class="op">:&gt;</span>xs) y <span class="ot">=</span> x <span class="op">:&gt;</span> snoc xs y</span></code></pre></div>
<p>but we would prefer to use the <code>append</code> we have already written.</p>
</div>
<div id="better-reverse-with-an-accumulator" class="slide section level1">
<h1>Better reverse with an accumulator</h1>
<pre><code>vrev3 :: Vec n a -&gt; Vec n a
vrev3 xs = vaccrev V0 xs

vaccrev :: Vec n a -&gt; Vec m a -&gt; Vec (n :+ m) a
vaccrev acc V0 = acc</code></pre>
<p>Oh noes, now we fail even in the base case:</p>
<pre><code>    • Could not deduce: (n :+ &#39;Z) ~ n</code></pre>
<p>Now we need to prove <code>n + 0 ~ n</code> too.</p>
</div>
<div id="type-equality-and-proofs" class="slide section level1">
<h1>Type Equality and proofs</h1>
<p>After the Idris/Coq part, this should seem familiar:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- cf Data.Type.Equality</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">:~:</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">:~:</span> b <span class="kw">where</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span>  a <span class="op">:~:</span> a</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- data a :~: b = (a ~ b) =&gt; Refl</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="ot">sym ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="op">:~:</span> a)</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>sym <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span>  <span class="co">-- seems trivial, but see if you can simplify it...</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a><span class="ot">trans ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="op">:~:</span> c) <span class="ot">-&gt;</span> (a <span class="op">:~:</span> c)</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>trans <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a><span class="ot">cong ::</span> <span class="kw">forall</span> f a b<span class="op">.</span>a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="op">:~:</span> f b</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a ~ b) implies (f a) implies (f b)</span></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="ot">subst ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>subst <span class="dt">Refl</span> <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
</div>
<div id="some-proofs" class="slide section level1">
<h1>Some proofs</h1>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Trivial lemma: 0+n ~ n; explicit quantification</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_id_l ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> (<span class="dt">Z</span> <span class="op">:+</span> n) <span class="op">:~:</span> n</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>plus_id_l _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- implicit quantification</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- plus_id_l_impl :: forall (n::Nat).(Z :+ n) :~: n </span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_id_l_impl ::</span> <span class="kw">forall</span><span class="ot"> n::</span><span class="dt">Nat</span><span class="op">.</span>(<span class="dt">Z</span> <span class="op">:+</span> n) <span class="op">:~:</span> n </span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_id_l_impl ::</span> (<span class="dt">Z</span> <span class="op">:+</span> n) <span class="op">:~:</span> n </span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>plus_id_l_impl <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Prove by induction: n+0 ~ n</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pattern-match on n, so explicit quantification</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Compare with Coq Agda or Idris</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_id_r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> (n <span class="op">:+</span> <span class="dt">Z</span>) <span class="op">:~:</span> n</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>plus_id_r <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Refl</span>                      <span class="co">-- (Z :+ Z) :~: Z </span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>plus_id_r (<span class="dt">SS</span> m) <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_id_r m) <span class="co">-- S(m :+ Z) :~: S m</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- @S is optional above, added only for clarity</span></span></code></pre></div>
</div>
<div id="one-more-lemma" class="slide section level1">
<h1>One more lemma</h1>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- n + S m ~ S(m+n)</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- implicit m, explicit n</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_succ_r ::</span> <span class="kw">forall</span> m n<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">S</span> m <span class="op">:~:</span> <span class="dt">S</span>(n <span class="op">:+</span> m)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>plus_succ_r <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>plus_succ_r (<span class="dt">SS</span> n1) <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_succ_r <span class="op">@</span>m n1)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- explicit m, n</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_succ_r2 ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> n <span class="op">:+</span> <span class="dt">S</span> m <span class="op">:~:</span> <span class="dt">S</span>(n <span class="op">:+</span> m)</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>plus_succ_r2 <span class="dt">SZ</span> m <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>plus_succ_r2 (<span class="dt">SS</span> n1) m <span class="ot">=</span> cong <span class="op">@</span><span class="dt">S</span> (plus_succ_r2 n1 m)</span></code></pre></div>
</div>
<div id="provably-safe-casts" class="slide section level1">
<h1>Provably safe casts</h1>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Typesafe cast using propositional equality</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- simple but not very useful (subst is more powerful)</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="ot">castWith ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>castWith <span class="dt">Refl</span> x <span class="ot">=</span> x</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Generalised form of typesafe cast</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="ot">gcastWith ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (a <span class="op">~</span> b <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>gcastWith <span class="dt">Refl</span> x <span class="ot">=</span> x</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a><span class="ot">simpl0r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f (n<span class="op">:+</span><span class="dt">Z</span>) <span class="ot">-&gt;</span> f n</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Special case: Vec (n:+Z) a -&gt; Vec n a</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>simpl0r n v <span class="ot">=</span> castWith (plus_id_r n) v</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- simpl0r n v = subst (plus_id_r n) v</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a><span class="ot">expand0r ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f n <span class="ot">-&gt;</span> f(n<span class="op">:+</span><span class="dt">Z</span>)</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>expand0r n x <span class="ot">=</span> subst (sym (plus_id_r n)) x</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- Instead of `subst ... sym` we can put the constraint solver to work</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- you can think of it as a kind of tactic</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a><span class="ot">expand0r&#39; ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> f n <span class="ot">-&gt;</span> f(n<span class="op">:+</span><span class="dt">Z</span>)</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>expand0r&#39; n x <span class="ot">=</span> gcastWith (plus_id_r n) x</span></code></pre></div>
</div>
<div id="type-safe-reverse" class="slide section level1">
<h1>Type-safe reverse</h1>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rev ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>rev [] <span class="ot">=</span> []</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>rev xs <span class="ot">=</span> go [] xs <span class="kw">where</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  go acc [] <span class="ot">=</span> acc</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  go acc (h<span class="op">:</span>t) <span class="ot">=</span> go (h<span class="op">:</span>acc) t</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="ot">accrev ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>accrev <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">V0</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>accrev xs <span class="ot">=</span> go <span class="dt">SZ</span> <span class="dt">V0</span> xs <span class="kw">where</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  by ::</span> (x <span class="op">~</span> y <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> (x <span class="op">:~:</span> y) <span class="ot">-&gt;</span> r</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>  value <span class="ot">`by`</span> proof <span class="ot">=</span> gcastWith proof value</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> <span class="kw">forall</span> m n a<span class="op">.</span><span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n<span class="op">:+</span>m)</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>  go alen acc <span class="dt">V0</span>     <span class="ot">=</span> acc</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>                       <span class="ot">`by`</span> plus_id_r alen               <span class="co">-- n ~ n + Z</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>  go alen acc (h<span class="op">:&gt;</span>t) <span class="ot">=</span>  go (<span class="dt">SS</span> alen) (h<span class="op">:&gt;</span>acc) t </span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>                       <span class="ot">`by`</span> (plus_succ_r2 alen (size t)) <span class="co">-- x + S y ~ S(x+y)         </span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- expand0r :: SNat n -&gt; f n -&gt; f(n:+Z)</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- plus_succ_r2 :: SNat n -&gt; SNat m -&gt; n :+ S m :~: S(n :+ m)</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> accrev <span class="op">$</span> <span class="dv">1</span> <span class="op">:&gt;</span> <span class="dv">2</span> <span class="op">:&gt;</span> <span class="dv">3</span> <span class="op">:&gt;</span> <span class="dt">V0</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>size <span class="dt">V0</span> <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>size (_<span class="op">:&gt;</span>t) <span class="ot">=</span> <span class="dt">SS</span> (size t)</span></code></pre></div>
</div>
<div id="exercises" class="slide section level1">
<h1>Exercises</h1>
<p>Exercise: implement a vector variant of</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">naiverev ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>naiverev [] <span class="ot">=</span> []</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>naiverev (x<span class="op">:</span>xs) <span class="ot">=</span> naiverev xs <span class="op">++</span> [x]</span></code></pre></div>
<p>Challenge: try to eliminate <code>size</code> from <code>accrev</code> by using proxies or type app</p>
<p>(there is <code>Data.Vect</code>, stackoverflow and blogs but try to roll your own before you peek at other solutions).</p>
</div>
<div id="questions" class="slide section level1">
<h1>Questions?</h1>
</div>
<div id="type-level-literals" class="slide section level1">
<h1>Type level literals</h1>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures, DataKinds #-}</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>) <span class="co">-- strings promoted to types</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ratio</span> ((%))</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Money</span> (<span class="ot">currency ::</span> <span class="dt">Symbol</span>) <span class="ot">=</span> <span class="dt">Money</span> <span class="dt">Rational</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="ot">fivePence ::</span> <span class="dt">Money</span> <span class="st">&quot;GBP&quot;</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>fivePence <span class="ot">=</span> <span class="dt">Money</span> (<span class="dv">5</span> <span class="op">%</span> <span class="dv">100</span>)</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="ot">twoEuros ::</span> <span class="dt">Money</span> <span class="st">&quot;EUR&quot;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>twoEuros <span class="ot">=</span> <span class="dt">Money</span> <span class="dv">2</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Money</span> c <span class="ot">-&gt;</span> <span class="dt">Money</span> c <span class="ot">-&gt;</span> <span class="dt">Money</span> c</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">Money</span> x) (<span class="dt">Money</span> y) <span class="ot">=</span> <span class="dt">Money</span> (x <span class="op">+</span> y)</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; add fivePence fivePence</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- Money (1 % 10)</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; add fivePence twoEuros</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;interactive&gt;:18:15: error:</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a><span class="co">--    • Couldn&#39;t match type ‘&quot;EUR&quot;’ with ‘&quot;GBP&quot;’</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a><span class="co">--      Expected type: Money &quot;GBP&quot;</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a><span class="co">--        Actual type: Money &quot;EUR&quot;</span></span></code></pre></div>
</div>
<div id="type-level-numbers-kind-level-tuples" class="slide section level1">
<h1>Type level numbers, kind level tuples</h1>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures, DataKinds #-}</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>, <span class="dt">Nat</span>)</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Discrete</span> (<span class="ot">currency ::</span> <span class="dt">Symbol</span>) (<span class="ot">scale ::</span> (<span class="dt">Nat</span>, <span class="dt">Nat</span>))</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dt">Integer</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="ot">oneDollar ::</span> <span class="dt">Discrete</span> <span class="st">&quot;USD&quot;</span> &#39;(<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>oneDollar <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dv">1</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="ot">oneDollarThirtyCents ::</span> <span class="dt">Discrete</span> <span class="st">&quot;USD&quot;</span> &#39;(<span class="dv">100</span>, <span class="dv">1</span>)</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>oneDollarThirtyCents <span class="ot">=</span> <span class="dt">Discrete</span> <span class="dv">130</span></span></code></pre></div>
<p>In <code>scale :: (Nat, Nat)</code>, <code>(,)</code> is the tuple type promoted to a kind via DataKinds.</p>
<p>In <code>'(100, 1), '(,)</code> is the tuple data constructor promoted to a type constructor.</p>
</div>
</body>
</html>
